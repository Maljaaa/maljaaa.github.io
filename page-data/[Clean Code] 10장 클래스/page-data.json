{"componentChunkName":"component---src-templates-blog-template-js","path":"/[Clean Code] 10장 클래스/","result":{"data":{"cur":{"id":"81335291-4af9-546a-bed4-e80d5ccc74a6","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>코드의 표현력과 그 코드로 이루어진 함수에 아무리 신경 쓸지라도<br>\n좀 더 차원 높은 단계까지 신경쓰지 않으면 깨끗한 코드를 얻기는 어렵다.</p>\n<h3 id=\"클래스-체계\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B2%B4%EA%B3%84\" aria-label=\"클래스 체계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 체계</h3>\n<p>표준 자바 관례에 따르면, 변수 목록이 가장 먼저 나온다.<br>\n<code class=\"language-text\">[변수 목록]</code> : <code class=\"language-text\">정적(static)</code>, <code class=\"language-text\">공개(public)</code> 상수 -> <code class=\"language-text\">정적 비공개(private)</code> -> 비공개 인스턴스변수<br>\n<code class=\"language-text\">[변수 목록]</code> -> <code class=\"language-text\">[공개 함수]</code> -> <code class=\"language-text\">[비공개 함수]</code><br>\n즉, 추상화 단계가 순차적으로 내려간다.<br>\n그래서 신문처럼 읽힌다.</p>\n<h4 id=\"캡슐화\" style=\"position:relative;\"><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94\" aria-label=\"캡슐화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캡슐화</h4>\n<p>같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면<br>\n그 함수나 변수를 <code class=\"language-text\">protected</code>로 선언하거나 패키지 전체로 공개한다.<br>\n캡슐화를 풀어주는 결정은 언제나 <strong>최후의 수단</strong>이다.</p>\n<h3 id=\"클래스는-작아야-한다\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%9E%91%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"클래스는 작아야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스는 작아야 한다!</h3>\n<p>함수는 <code class=\"language-text\">행 수</code>로 크기를 측정했다면, 클래스는 <code class=\"language-text\">맡은 책임</code>을 센다.</p>\n<p>클래스 이름에 <code class=\"language-text\">Processor</code>, <code class=\"language-text\">Manager</code>, <code class=\"language-text\">Super</code> 등과 같이 모호한 단어가 있다면<br>\n클래스에다 여러 책임을 떠 안겼다는 증거다.<br>\n또한 클래스 설명을 <code class=\"language-text\">만일(\"if\")</code>, <code class=\"language-text\">그리고(\"and\")</code>, <code class=\"language-text\">-(하)며(\"or\")</code>, <code class=\"language-text\">하지만(\"but\")</code>을 사용하지 않고서<br>\n25단어 내외로 가능해야 한다.</p>\n<h4 id=\"단일-책임-원칙\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\" aria-label=\"단일 책임 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 책임 원칙</h4>\n<p><code class=\"language-text\">단일 책임 원칙(Single Responsibility Principle, SRP)</code>은<br>\n클래스나 모듈을 <strong>변경할 이유</strong>가 하나, 단 하나뿐이어야 한다는 원칙이다.</p>\n<p>큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.<br>\n작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며,<br>\n다른 작은 클래스와 합력해 시스템에 필요한 동작을 수행한다.</p>\n<h4 id=\"응집도\" style=\"position:relative;\"><a href=\"#%EC%9D%91%EC%A7%91%EB%8F%84\" aria-label=\"응집도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>응집도</h4>\n<p>우리는 응집도가 높은 클래스를 선호한다.<br>\n응집도가 높다는 것은 클래스에 속한 매서드와 변수가 서로 의존하며<br>\n논리적인 단위로 묶인다는 의미다.<br>\n‘함수를 작게, 매개변수 목록을 짧게’라는 전략을 따르다보면,<br>\n때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 만하진다.<br>\n그럴 땐 새로운 클래스로 쪼개야한다.</p>\n<h4 id=\"응집도를-유지하면-작은-클래스-여럿이-나온다\" style=\"position:relative;\"><a href=\"#%EC%9D%91%EC%A7%91%EB%8F%84%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%98%EB%A9%B4-%EC%9E%91%EC%9D%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%97%AC%EB%9F%BF%EC%9D%B4-%EB%82%98%EC%98%A8%EB%8B%A4\" aria-label=\"응집도를 유지하면 작은 클래스 여럿이 나온다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>응집도를 유지하면 작은 클래스 여럿이 나온다</h4>\n<p>저자는 커누스 교수가 쓴 책 ‘Literate Programming’에 나오는 예제를 소개한다.<br>\n리팩털이한 결과 프로그램이 늘어났다.</p>\n<ol>\n<li>좀 더 길고 서술적인 변수 이름 사용</li>\n<li>코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언 활용</li>\n<li>가독성을 높이고자 공백을 맞추고 형식을 맞춤</li>\n</ol>\n<h3 id=\"변경하기-쉬운-클래스\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9A%B4-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"변경하기 쉬운 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경하기 쉬운 클래스</h3>\n<p>클래스에 손대는 순간 설계를 개선하려는 고민과 시도가 필요하다.<br>\n또한 클래스 일부에서만 사용되는 비공개 매서드는 코드를 개선할 잠재적인 여지를 시사한다.</p>\n<p>저자는 예시로 sql클래스를 들었다.<br>\n여기서 SRP와 OCP를 챙긴다.<br>\n즉, UpdateSql 클래스를 제자리에 끼워 넣으면 끝난다.</p>\n<p>이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 건드리지 않는다.</p>\n<h4 id=\"변경으로부터-격리\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0-%EA%B2%A9%EB%A6%AC\" aria-label=\"변경으로부터 격리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경으로부터 격리</h4>\n<p>우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.</p>\n<p>시스템의 결합도를 낮추면 <code class=\"language-text\">유연성</code>과 <code class=\"language-text\">재사용성</code>도 더욱 높아진다.<br>\n결합도를 최소로 줄이면 <code class=\"language-text\">DIP(Dependency Inversion Principle)</code>를 따르는 클래스가 나온다.<br>\nDIP는 클래스가 상세한 구현이 아니라 <code class=\"language-text\">추상화</code>에 의존해야 한다는 원칙이다.</p>\n<h3 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h3>\n<p>함수와 같은 것 같다.<br>\n인스턴스가 많으면 쪼개서 응집도를 높인다.<br>\n그러다 특정 매서드에만 쓰이는 변수가 많아지면 클래스를 쪼갠다.<br>\n클래스는 책임이 하나인지를 집중해서 살펴본다.<br>\n즉, 쪼개라!!</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#intro\">Intro</a></p>\n<ul>\n<li>\n<p><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B2%B4%EA%B3%84\">클래스 체계</a></p>\n<ul>\n<li><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94\">캡슐화</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%9E%91%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4\">클래스는 작아야 한다!</a></p>\n<ul>\n<li><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\">단일 책임 원칙</a></li>\n<li><a href=\"#%EC%9D%91%EC%A7%91%EB%8F%84\">응집도</a></li>\n<li><a href=\"#%EC%9D%91%EC%A7%91%EB%8F%84%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%98%EB%A9%B4-%EC%9E%91%EC%9D%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%97%AC%EB%9F%BF%EC%9D%B4-%EB%82%98%EC%98%A8%EB%8B%A4\">응집도를 유지하면 작은 클래스 여럿이 나온다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9A%B4-%ED%81%B4%EB%9E%98%EC%8A%A4\">변경하기 쉬운 클래스</a></p>\n<ul>\n<li><a href=\"#%EB%B3%80%EA%B2%BD%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0-%EA%B2%A9%EB%A6%AC\">변경으로부터 격리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"Intro 코드의 표현력과 그 코드로 이루어진 함수에 아무리 신경 쓸지라도 좀 더 차원 높은 단계까지 신경쓰지 않으면 깨끗한 코드를 얻기는 어렵다. 클래스 체계 표준 자바 관례에 따르면, 변수 목록이 가장 먼저 나온다.  : ,  상수 ->  -> 비공개 인스턴스변수  ->  ->  즉, 추상화 단계가 순차적으로 내려간다. 그래서 신문처럼 읽힌다. 캡슐화 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 로 선언하거나 패키지 전체로 공개한다. 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다. 클래스는 작아야 한다! 함수는 로 크기를 측정했다면, 클래스는 을 센다. 클래스 이름에 , ,  등과 같이 모호한 단어가 있다면 클래스에다 여러 책임을 떠 안겼다는 증거다. 또한 클래스 설명을 , , , 을 사용하지 않고서 25단어 내외로 가능해야 한다. 단일 책임 원칙 은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다. 큰 클…","frontmatter":{"date":"September 10, 2024","title":"10장 클래스","categories":"Clean_Code","author":"신승민","emoji":"😐"},"fields":{"slug":"/[Clean Code] 10장 클래스/"}},"next":{"id":"198143c9-5deb-53cc-ae66-f201090f4562","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>이 장에서는 단위 테스트에 대해 다룬다.<br>\n과거엔 드라이버 코드를 급조해 결과물이 나오는 것을 팀원들에게 보여줘야 했다.<br>\n그리고 버렸다.<br>\n하지만 현재는 <strong>애자일</strong>과 <strong>TDD</strong> 덕택에 단위 테스트를 <strong>자동화</strong>하는 프로그래머들이 많아졌다.<br>\n그러던 중 많은 프로그래머들이 놓친 미묘한 사실을 알아가보자.</p>\n<h3 id=\"tdd-법칙-세-가지\" style=\"position:relative;\"><a href=\"#tdd-%EB%B2%95%EC%B9%99-%EC%84%B8-%EA%B0%80%EC%A7%80\" aria-label=\"tdd 법칙 세 가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TDD 법칙 세 가지</h3>\n<ul>\n<li><strong>첫째 법칙</strong>: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.</li>\n<li><strong>둘째 법칙</strong>: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.</li>\n<li><strong>셋째 법칙</strong>: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.</li>\n</ul>\n<p>위 세 가지 법칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다.<br>\n또한 매일 많은 양에 달하는 테스트 케이스가 나온다.<br>\n사실상 전부 테스트하는 테스트 케이스가 나온다.<br>\n하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.</p>\n<h3 id=\"깨끗한-테스트-코드-유지하기\" style=\"position:relative;\"><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0\" aria-label=\"깨끗한 테스트 코드 유지하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>깨끗한 테스트 코드 유지하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"테스트 코드는 실제 코드 못지 않게 중요하다.\"</code></pre></div>\n<p>저자는 테스트 코드에 팀원들간 규칙을 깨도 좋다고 허용한 팀을 예시로 든다.<br>\n테스트 코드를 잘 짜는 것보다, 안 짜는 것보다 짜는 것이 좋다고 판단했을 것이다.<br>\n실제 코드가 변할 때 테스트 코드도 변한다.  <code class=\"language-text\">그런데</code>테스트 코드<code class=\"language-text\">가 지저분할 수록 </code>실제 코드를 변경하기 어렵다.<br>\n<code class=\"language-text\">테스트 코드</code>가 복잡할수록 <code class=\"language-text\">실제 코드</code>를 짜는 시간보다 시간이 더 걸린다.<br>\n<code class=\"language-text\">실제 코드</code>를 변경해 기존 <code class=\"language-text\">테스트 케이스</code>가 실패하기 시작하면,<br>\n지저분한 <code class=\"language-text\">테스트 코드</code>로 인해, 실패하는 <code class=\"language-text\">테스트 케이스</code>를 점점 통과시키기 어려워진다.</p>\n<p>테스트 슈트가 없으면 개발자는 검증하지 못한다.<br>\n결국 결함율이 높아진다.<br>\n의도하지 않은 결함이 많아지면, 변경을 주저한다.<br>\n변경하면 손해가 크다 생각해 더 이상 코드를 정리하지 않는다.<br>\n그러면서 코드가 망가지기 시작한다.<br>\n결국 <strong>테스트 슈트</strong>도 없고, <strong>얼기설기 뒤섞인 코드</strong>에, <strong>좌절한 고객</strong>과, 테스트에 쏟아 부은 노력이 허사였다는 <strong>실망감</strong>만 남는다.</p>\n<p>그러므로 테스트 코드를 실제 코드 못지 않게 깨끗하게 짜야한다.</p>\n<h4 id=\"테스트는-유연성-유지보수성-재사용성을-제공한다\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EC%9C%A0%EC%97%B0%EC%84%B1-%EC%9C%A0%EC%A7%80%EB%B3%B4%EC%88%98%EC%84%B1-%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%84%B1%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%9C%EB%8B%A4\" aria-label=\"테스트는 유연성 유지보수성 재사용성을 제공한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트는 유연성, 유지보수성, 재사용성을 제공한다.</h4>\n<p>코드에 <strong>유연성</strong>, <strong>유지보수성</strong>, <strong>재사용성</strong>을 제공하는 버팀목이 바로 <code class=\"language-text\">단위 테스트</code>이다.<br>\n아무리 아키텍처가 유연하고, 설계를 잘 나눠도, 테스트 케이스가 없으면 개발자는 변경을 주저한다.<br>\n<strong>버그</strong>가 숨어들까 두렵기 때문이다.<br>\n하지만 테스트 케이스가 있다면 괜찮다.<br>\n테스트 케이스가 제공하는 것들로 인해 변경이 쉬워진다.</p>\n<p>따라서 테스트 코드가 지저분하면 코드를 <strong>변경하는 능력</strong>이 떨어지며<br>\n코드 <strong>구조를 개선하는 능력</strong>도 떨어진다.<br>\n테스트 코드가 지저분할수록 실제 코드도 지저분해진다.<br>\n테스트 코드를 잃어버리고 실제 코드도 망가진다.</p>\n<h3 id=\"깨끗한-테스트-코드\" style=\"position:relative;\"><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C\" aria-label=\"깨끗한 테스트 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>깨끗한 테스트 코드</h3>\n<p>깨끗한 테스트 코드를 만드는 데 가장 중요한 것은 <code class=\"language-text\">가독성</code>이다.<br>\n<code class=\"language-text\">명료성</code>, <code class=\"language-text\">단순성</code>, <code class=\"language-text\">풍부한 표현력</code>이 필요하다.</p>\n<p>저자는 여기서 테스트 코드를 예시로 든다.<br>\n<code class=\"language-text\">addPage</code>와 <code class=\"language-text\">assertSubString</code>을 부르느라 중복이 되는 코드가 많은 코드를 말이다.<br>\n여기선 <code class=\"language-text\">BUILD-OPERATE-CHECK 패턴</code>이 적합하다.</p>\n<ul>\n<li><strong>BUILD</strong>: 테스트 자료를 만든다.</li>\n<li><strong>OPERATE</strong>: 테스트 자료를 조작한다.</li>\n<li><strong>CHECK</strong>: 조작한 결과가 올바른지 확인한다.</li>\n</ul>\n<blockquote>\n<p>GIVEN-WHEN-THEN 패턴과 비슷하다.</p>\n</blockquote>\n<h4 id=\"도메인에-특화된-테스트-언어dsl\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8%EC%97%90-%ED%8A%B9%ED%99%94%EB%90%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%96%B8%EC%96%B4dsl\" aria-label=\"도메인에 특화된 테스트 언어dsl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도메인에 특화된 테스트 언어(DSL)</h4>\n<p>흔히 쓰는 시스템 조작 API를 사용하는 대신<br>\nAPI 위에다 함수와 유틸리티를 구현한 후 그 함수와 유틸리티를 사용하므로<br>\n테스트 코드를 짜기도 읽기도 쉬워진다.<br>\n이러한 코드는 코드를 계속 리팩터링하다가 진화된 API다.</p>\n<h4 id=\"이중-표준\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A4%91-%ED%91%9C%EC%A4%80\" aria-label=\"이중 표준 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이중 표준</h4>\n<p>저자는 온도가 ‘급격하게 떨어지면’ 경보, 온풍기, 송풍기가<br>\n모두 가동되는지 확인하는 코드를 예시로 든다.</p>\n<blockquote>\n<p>정말 신기한 사실은 저자가 말한대로 내가 코드를 읽었다는 것이고 그게 피곤했다는 것이다.</p>\n</blockquote>\n<p>저자는 코드를 함수로 감추고, 정보를 간결하게 표현함으로써 해결한다.<br>\n하지만 <code class=\"language-text\">그릇된 정보를 피하라</code>는 규칙의 위반이지만, 현 상황에는 적절하다.</p>\n<p>다른 예시로는 제한적인 환경에 대해 말한다.<br>\n임베디드 시스템에서 컴퓨터 자원과 메모리가 제한적일 가능성이 많다.<br>\n하지만 테스트 환경은 자원이 제한적일 가능성이 낮다.<br>\n즉, 실제 환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식이 있다.<br>\n대개 메모리나 CPU 효율과 관련 있는 경우다.<br>\n코드의 깨끗함과는 철저히 무관하다.</p>\n<h3 id=\"테스트당-assert-하나\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%B9-assert-%ED%95%98%EB%82%98\" aria-label=\"테스트당 assert 하나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트당 assert 하나</h3>\n<p>JUnit으로 테스트 코드를 짤 때는 함수마다 assert 문을 단 하나만 사용해야 한다고 주장하는 학파가 있다.<br>\n그래서 <code class=\"language-text\">GIVEN-WHEN-THEN</code> 이라는 관례를 많이 사용한다.<br>\n이로써 테스트 코드를 읽기 쉬워지지만, 테스트를 분리하면 중복되는 코드가 많아진다.<br>\n<code class=\"language-text\">TEMPLATE METHOD 패턴</code>을 사용하면 중복을 제거할 수 있다.<br>\ngiven/when 부분을 <strong>부모 클래스</strong>에 두고, then 부분을 <strong>자식 클래스</strong>에 두면 된다.<br>\n혹은 given/when 부분을 <strong>@Before 함수</strong>에 두고, then 부분을 <strong>@Test 함수</strong>에 둬도 된다.<br>\n하지만 배보다 배꼽이 더 크다.</p>\n<p>때로는 함수 하나에 assert 문을 여러 개 넣기도 하지만 assert 문 개수는 최대한 줄여야 좋겠다.</p>\n<h4 id=\"테스트당-개념-하나\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%B9-%EA%B0%9C%EB%85%90-%ED%95%98%EB%82%98\" aria-label=\"테스트당 개념 하나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트당 개념 하나</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"테스트 함수마다 한 개념만 테스트하라.\"</code></pre></div>\n<p>이 규칙이 더 낫겠다.</p>\n<p>저자는 여기서 독자적인 개념 세 개를 테스트하는 코드를 예시로 든다.<br>\n세 개념을 한 함수로 몰아넣으면,<br>\n각 절이 존재하는 이유와 각 절이 테스트하는 개념을 모두 이해해야 한다.<br>\n하지만 assert 문이 여럿이라는 사실이 문제가 아니다.</p>\n<p>따라서 한 테스트 함수에서 여러 개념을 테스트한다는 사실이 문제다.<br>\n그러므로 가장 좋은 규칙은 <code class=\"language-text\">개념 당 assert 문 수를 최소로 줄여라</code>와<br>\n<code class=\"language-text\">테스트 함수 하나는 개념 하나만 테스트 하라</code>라 하자.</p>\n<h3 id=\"first\" style=\"position:relative;\"><a href=\"#first\" aria-label=\"first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>F.I.R.S.T.</h3>\n<p>깨끗한 테스트는 다음 다섯 가지 규칙을 따른다.</p>\n<ul>\n<li><strong>Fast(빠르게)</strong>: 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. 코드를 마음껏 정리하지도 못한다. 결국 코드 품질이 망가지기 시작한다.</li>\n<li><strong>Independent(독립적으로)</strong>: 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.</li>\n<li><strong>Repeatable(반복가능하게)</strong>: 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. 게다가 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다.</li>\n<li><strong>Self-Validating(자가검증하는)</strong>: 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다.</li>\n<li><strong>Timely(적시에)</strong>: 실제 코드가 테스트하기 어렵다는 사실을 발견할지 모른다. 어떤 실제 코드는 테스트하기 너무 어렵다고 판명날지 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.</li>\n</ul>\n<h3 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h3>\n<p>테스트 코드는 실제 코드의 <code class=\"language-text\">유연성</code>, <code class=\"language-text\">유지보수성</code>, <code class=\"language-text\">재사용성</code>을 보존하고 강화한다.<br>\n그러므로 테스트 코드는 지속적으로 깨끗하게 관리하자.<br>\n표현력을 높이고 간결하게 정리하자.<br>\n테스트 API를 구현해 <code class=\"language-text\">도메인 특화 언어(Domain Specific Language)</code>를 만들자.</p>\n<p>또한 모르던 개념을 알게 되었다.</p>\n<ul>\n<li><strong>웹 로봇(크롤러)</strong>: 사람과의 상호작용 없이 연속된 웹 트랜잭션들을 자동으로 수행하는 소프트웨어 프로그램이다. 콘텐츠를 가져오고, 하이퍼링크를 따라가고, 발견한 데이터를 처리한다.</li>\n<li><strong>BUILD-OPERATE-CHECK 패턴</strong>: given-when-then이랑 같은 의미</li>\n<li><strong>TEMPLATE METHOD 패턴</strong>: 여러 클래스에서 공통으로 사용하는 매서드를 템플릿화 하여 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴</li>\n</ul>\n<p>직접 테스트 코드를 짜본 것은 강의를 따라한 정도다.<br>\n내가 일하는 곳에서는 테스트 코드를 작성하지 않고, 바로 유저 테스트로 넘어간다.<br>\n여기서 나는 항상 결함에 대한 불안감이 있었다.<br>\n유지보수를 하면서도 항상 불안해 있다.<br>\n변경에 주저한다는 것과 코드를 다시 안 보게 된다는 말에 동감한다.<br>\n이번 글을 통해 깨끗한 테스트 코드의 중요성을 알게 되었고, 회사에 적용할 수 있는 방법을 강구해봐야겠다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#intro\">Intro</a></p>\n<ul>\n<li>\n<p><a href=\"#tdd-%EB%B2%95%EC%B9%99-%EC%84%B8-%EA%B0%80%EC%A7%80\">TDD 법칙 세 가지</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0\">깨끗한 테스트 코드 유지하기</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EC%9C%A0%EC%97%B0%EC%84%B1-%EC%9C%A0%EC%A7%80%EB%B3%B4%EC%88%98%EC%84%B1-%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%84%B1%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%9C%EB%8B%A4\">테스트는 유연성, 유지보수성, 재사용성을 제공한다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C\">깨끗한 테스트 코드</a></p>\n<ul>\n<li><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8%EC%97%90-%ED%8A%B9%ED%99%94%EB%90%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%96%B8%EC%96%B4dsl\">도메인에 특화된 테스트 언어(DSL)</a></li>\n<li><a href=\"#%EC%9D%B4%EC%A4%91-%ED%91%9C%EC%A4%80\">이중 표준</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%B9-assert-%ED%95%98%EB%82%98\">테스트당 assert 하나</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%B9-%EA%B0%9C%EB%85%90-%ED%95%98%EB%82%98\">테스트당 개념 하나</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#first\">F.I.R.S.T.</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 09, 2024","title":"9장 단위 테스트","categories":"Clean_Code","author":"신승민","emoji":"🐒"},"fields":{"slug":"/[Clean Code] 9장 단위 테스트/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://maljaaa.github.io","comments":{"utterances":{"repo":"maljaaa/maljaaa.github.io"}}}}},"pageContext":{"slug":"/[Clean Code] 10장 클래스/","nextSlug":"/[Clean Code] 9장 단위 테스트/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}