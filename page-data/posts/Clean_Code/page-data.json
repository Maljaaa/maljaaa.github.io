{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Clean_Code","result":{"pageContext":{"currentCategory":"Clean_Code","categories":["All","Clean_Code","DB","Spring_MVC","Google_Sheets","API","Architecture"],"edges":[{"node":{"id":"d2e57b72-d352-581f-86a7-ca686b9cc6a5","excerpt":"Intro 변수를 으로 정의하는 이유가 있다. 남들이 변수에 의존하지 않게 만들기 위해서다. 그렇다면 왜 많은 개발자들이 함수와 함수를 당연하게 해 변수를 외부에 노출할까? 자료 추상화 더 나은 예시 변수를 private으로 선언하더라도 각 값마다 get함수와 set함수를 제공한다면 구현을 외부로 노출하는 셈이다. 구현을 감추려면 추상화가 필요하다. 더 나은 예시 인터페이스나 조회/설정 함수만으로는 추상화가 이뤄지지 않는다. 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다. 자료/객체 비대칭 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 제공한다. 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 절차 지향 코드의 장단점 객체 지향 코드의 장단점 객체 지향 코드에서 어려운 변경은 절차 지향 코드에서 쉬우며, 절차 지향 코드에서 어려운 변경은 객체 지향 코드에서 쉽다! 디미터 법칙 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신…","fields":{"slug":"/[Clean Code] 6장 객체와 자료 구죠/"},"frontmatter":{"categories":"Clean_Code","title":"6장 객체와 자료 구조","date":"September 04, 2024"}},"next":{"fields":{"slug":"/[Clean Code] 5장 형식 맞추기/"}},"previous":null},{"node":{"id":"703db23a-f43d-5ff7-b771-809fa6de8a3b","excerpt":"Intro 깔끔하게 형식을 맞춰 코드를 짜야한다. 간단한 규칙을 정하고, 그 규칙을 착실히 따라야 한다. 팀으로 일한다면 팀 규칙을 따라야 한다. 필요하다면 도구도 활용하자. 형식을 맞추는 목적 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다. 맨 처음 잡아놓는 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다. 원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다. 적절한 행 길이를 유지하라 소스 코드는 얼마나 길어야 적당할까? 라는 질문에 이렇게 답한다. 500줄을 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다. 신문 기사처럼 작성하라 이름은 간단하면서도 설명이 가능하게 짓는다. 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 세세하게 묘사한다. 마지막에는 가장 저차원 함수와 세부 내역이 나온다. 개념은 빈 행으로 분리하라 생각 사이는 빈 행을 넣어 분리하자. 행 묶음…","fields":{"slug":"/[Clean Code] 5장 형식 맞추기/"},"frontmatter":{"categories":"Clean_Code","title":"5장 형식 맞추기","date":"September 03, 2024"}},"next":{"fields":{"slug":"/[Clean Code] 4장 주석/"}},"previous":{"fields":{"slug":"/[Clean Code] 6장 객체와 자료 구죠/"}}},{"node":{"id":"22cd5d55-bdc5-537b-8b3c-76a5d57c0428","excerpt":"Intro 코드로 의도를 표현하지 못했을 때, 즉 실패했을 때 우리는 주석을 사용한다. 하지만 주석은 프로그래머들이 유지보수하기는 현실적으로 불가능하다. 따라서 우리는 주석이(간혹 필요할지라도) 필요 없는 방향으로 애너지를 쏟아야 한다. 주석은 나쁜 코드를 보완하지 못한다 코드로 의도를 표현하라! 주석으로 의도를 표현한 경우 코드로 의도를 표현한 경우 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다. 좋은 주석 1) 법적인 주석 2) 정보를 제공하는 주석 이왕이면 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 좋고 더 깔끔하겠다. 3) 의도를 설명하는 주석 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명할 수 있다. 4) 의미를 명료하게 밝히는 주석 테스트 코드에서 사용할 수 있다. 5) 결과를 경고하는 주석 프로그램 효율을 높이기 위해 정적 초기화 함수를 사용하려던 열성적인 프로그래머가 주석 때문에 실수를 면한다. 6) TODO 주석 앞으로 할 …","fields":{"slug":"/[Clean Code] 4장 주석/"},"frontmatter":{"categories":"Clean_Code","title":"4장 주석","date":"September 02, 2024"}},"next":{"fields":{"slug":"/[Clean Code] 3장 함수/"}},"previous":{"fields":{"slug":"/[Clean Code] 5장 형식 맞추기/"}}},{"node":{"id":"7338da3f-242d-511b-bb5a-c64a2bbe6112","excerpt":"Intro 추상화 수준이 너무 다양하고 코드가 길다. 두 겹으로 중첩된 if문은 이상한 플래그를 확인하고, 이상한 문자열을 사용하며, 이상한 함수를 호출한다. 코드를 이해하기가 어렵다. 하지만 매서드 몇 개를 추출하고, 이름 몇 개를 변경하고, 구조를 조금 변경하면 파악하기 어려웠던 정보가 쉽게 드러난다. 작게 만들어라 100줄 ~ 300줄 함수도 있고 20줄 ~ 30줄 함수도 있다. 최대한 작으면 작을 수록 좋다. 심지어 2줄 ~ 4줄인 함수도 있다. 줄일 수 있다면 줄이는게 좋다. 블록과 들여쓰기 if문 / else문 / while 문 등에 들어가는 블록은 한 줄이어야 한다. -> 대개 여기서 함수를 호출한다 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 한 가지만 해라! 우리가 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서이다. 그렇기 때문에 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면, …","fields":{"slug":"/[Clean Code] 3장 함수/"},"frontmatter":{"categories":"Clean_Code","title":"3장 함수","date":"August 30, 2024"}},"next":{"fields":{"slug":"/[Clean Code] 2장 의미있는 이름/"}},"previous":{"fields":{"slug":"/[Clean Code] 4장 주석/"}}},{"node":{"id":"ad644289-7809-51c4-a31d-49de2becd758","excerpt":"Intro 나는 평소에 네이밍을 하는데 어려움이 있었다. 여러 컨벤션들이 있었지만, 내가 옆에 두고 하지 않는 이상 좋은 네이밍을 하기엔 어려웠다. 아직은 경험이 없고 익숙하지 않아서 일까?… 그래서 더더욱 이번 챕터를 재미있게 봤다. 의도를 분명히 밝혀라 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다. 여기서 d는 아무 의미도 드러나지 않는다. 의도가 드러나는 이름을 사용하면 코드 이해와 변경이 쉬워진다. 그러면서도 영어 동사의 표현을 잘 알아야겠다는 생각이 든다. 다음 코드가 무엇을 하는지 살펴보자. 복잡한 문장은 없다. 공백과 들여쓰기도 적당하다. 변수는 세개, 상수는 두 개뿐이다. 문제는 코드의 단순성이 아니라 코드의 함축성이다. 즉, 코드 맥락이 코드 자체에 명시적으로 드러나지 않는다. theList에 무엇이 들었는가? theList에서 0번째 값이 어째서 중요한가? 값 4는 무슨 의미인가? 함수가 반환하는 리스트 list1을 어떻게 사용하는가? 그렇다면 …","fields":{"slug":"/[Clean Code] 2장 의미있는 이름/"},"frontmatter":{"categories":"Clean_Code","title":"2장 의미있는 이름","date":"August 28, 2024"}},"next":{"fields":{"slug":"/[Clean Code] 1장 깨끗한 코드/"}},"previous":{"fields":{"slug":"/[Clean Code] 3장 함수/"}}},{"node":{"id":"e7746db5-6421-5dfc-8523-7dfbeddaf021","excerpt":"Intro 회사에서 유지보수를 하다가 끔찍한 프로젝트를 보게 되었다. 변수명과 클래스 명은 모두 1,2,3 혹은 A, B, C로 구분되어 있었다. 이런 이유 때문에 유지보수 하는 일이 너무 힘들었다. 그래서 어떻게 하면 나는 이런 코드를 짜지 않을 수 있을까? 어떻게 하면 이 코드를 좋은 코드로 바꿀 수 있을까?라는 의문점이 생겼다. 그래서 미루고 미뤄왔던 클린코드를 읽어보려고 한다. 코드가 존재하리라 요즘 기술이 발전함에 따라 코드를 자동으로 생성해주는 기술들이 생겨나기 시작했다. 그럼에도 저자는 코드가 사라질 가망이 없다고 한다. 나쁜 코드 80년대 후반 킬러 앱 하나를 구현한 회사를 이야기하면서 시작한다. 회사가 망했는데, 그 원인은 바로 나쁜 코드 탓이었다. 나쁜 코드에 발목이 잡혀 고생하는 것을 고행(Wading)이라 부른다. 나쁜 코드로 치르는 대가 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 그러다 팀은 재설계를 요구한다. 새로운 프로젝트를 시작하기 때문에 모두가 합류…","fields":{"slug":"/[Clean Code] 1장 깨끗한 코드/"},"frontmatter":{"categories":"Clean_Code","title":"1장 깨끗한 코드","date":"August 27, 2024"}},"next":{"fields":{"slug":"/Database의 책임/"}},"previous":{"fields":{"slug":"/[Clean Code] 2장 의미있는 이름/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}